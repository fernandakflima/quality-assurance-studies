# Learning Roadmap for Software Quality
- Fundamentals of Software Quality
- Fundamentals of Web applications and Networks
- CI/CD
- Software Testing
- Automated tests
- Programming fundamentals
- Design patterns and Systems Architecture
- Fundamentals of Computer Science
- Software Processes and life cycle

## Software Quality fundamentals
- Quality definitions
- Prioritization and testing techniques
- Test plan and documentation
- Test case management
- Test taxonomy
- Defect management
- Metrics

## Software processes and life cycle
- Software process models
- Agile software development
- Tests within the agile model

## Fundamentals of Web Applications and Networks
- Network fundamentals
- Internet architecture and important protocols
- Operation of webpages
- Languages ​​and technologies

## Fundamentals of Computer Science
- Representation and data structure
- Compilation x Interpretation
- Competition and threading
- Operating system concepts
- Algorithms and complexity

## Programming fundamentals
- Use of command line
- Editors and IDEs
- Syntax and control flow
- Programming paradigms

## Design patterns and systems architecture
- Concepts and types of patterns
- Types of architecture
- Systems modeling

## Automated tests
- Test pyramid
- Automation as an investment
- Types of automated tests
- Frameworks for automation
- Fake objects and their types
- BDD and Gherkin language

## CI/CD
- Version strategy and technologies
- Deploys, release and orchestration
- Configuration and builds
- Use of containers
- Tests integrated into the pipeline
- Device farms and remote execution

## Soft skills and mindset of a QA
### Mistakes that QAs can make
- Failures in the analysis of an occurrence
- Fear of asking questions
- Faulty and standardless automations
- Forget user
- Blaming others for bugs
- Not having a vision of what happens in production
- Not caring about technical development processes

## Thinking about the characteristics of the software
1. Functionality
    - Are the features appropriate?
    - Were they implemented correctly?
    - How is the data being stored?
    - Is the system responsive?

2. Reliability
    - How does the software behave under specific failure conditions?
    - How often does it fail?
    - What is the recovery time?

3. Usability
    - Do users understand the software?
    - What effort is there for this understanding?

4. Efficiency
    - Does the development team follow good practices?
    - Was the project architecture designed to be efficient?

5. Maintainability
    - How difficult is it to find a problem and fix it?
    - How much effort does it take to modify the code?

6. Portability
    - Does the system adapt to changes in the environment?
    - How difficult is it to migrate a system component?